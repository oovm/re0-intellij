{
    parserClass = "restart.language.parser.RestartParser"
    parserUtilClass = "restart.language.psi.RestartParserExtension"

    extends = "restart.language.ast.RestartASTBase"

    psiClassPrefix = "Restart"
    psiImplClassSuffix = "Node"
    psiPackage = "restart.language.psi"
    psiImplPackage = "restart.language.psi_node"

    elementTypeHolderClass = "restart.language.psi.RestartTypes"
    elementTypeClass = "restart.language.psi.RestartTokenType"
    tokenTypeClass = "restart.language.psi.RestartTokenType"

    psiImplUtilClass = "restart.language.ast.ASTMethods"
    generateTokenAccessors = false

    tokens = [
        COMMENT_SL = "//"
        COMMENT_TEXT = "Comment"
        // literal
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        STRING_START = "StringStart"
        STRING_TEXT = "StringText"
        STRING_END = "StringEnd"
        BYTE = "Byte"

        DOT = '.'
        SEMICOLON = ';'
        COLON = ':'
        OP_PROPORTION = "::"

        OP_INC = "++"
        OP_ADD_ASSIGN = "+="
        OP_ADD = "+"
        OP_DEC = "--"
        OP_SUB_ASSIGN = "-="
        OP_SUB = "-"
        OP_MUL_ASSIGN = "*="
        OP_MUL = "*"
        OP_DIV_ASSIGN = "/="
        OP_DIV = "/"
        OP_MOD_ASSIGN = "%="
        OP_MOD = "%"

        OP_AND = "&"
        OP_OR = "|"
        OP_POW = "^"
        // DOTS
        OP_ARROW = "->"
        OP_ARROW2 = "=>"
        //
        OP_EQ = "="
        OP_NE = "!="
        OP_BIND = ":="
        OP_NOT = "!"
        //
        OP_GT = ">"
        OP_GS = "/>"
        OP_GG = ">>"
        OP_GEQ = ">="
        OP_GGG = ">>>"
        //
        OP_LT = "<"
        OP_LS = "</"
        OP_LL = "<<"
        OP_LEQ = "<="
        OP_LLL = "<<<"
        OP_EMPTY = "(!)"

        OP_IS_A = "is"
        OP_NOT_A = "is not"

        OP_IN = "in"
        OP_NOT_IN = "not_in"
        OP_AND_THEN = "and_then"
        OP_OR_ELSE = "or_else"
        OP_FORALL = "forall"
        OP_EXISTS = "exists"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
    ]
}

re0 ::= ((top_statements|normal_statements) [SEMICOLON])*
private top_statements ::=
    property_statement
  | event_statement
  | hero_statement
  | archive_statement
  | talent_statement
//  | declare_statement
  ;
private normal_statements ::=
    if_statement
  | expression
  ;
// ---------------------------------------------------------------------------------------------------------------------
declare_statement  ::= kw_declare identifier [modifiers] declare_block {
    mixin="restart.language.mixin.MixinDeclare"
}
kw_declare         ::= identifier
declare_block      ::= <<brace_free declare_item delimiter>>
declare_item       ::=
      declare_key COLON? declare_block
    | declare_key COLON? <<bracket_free normal_statements delimiter>>
    | declare_key COLON normal_statements {
    mixin="restart.language.mixin.MixinDeclareItem"
}
declare_key        ::= identifier | number | KW_IF {
    mixin="restart.language.mixin.MixinKey"
}
// ---------------------------------------------------------------------------------------------------------------------
property_statement ::= kw_property identifier [modifiers] declare_block {
    mixin="restart.language.mixin.MixinProperty"
};
kw_property        ::= "variable" | "property" | "属性" | "内置";
// ---------------------------------------------------------------------------------------------------------------------
event_statement    ::= kw_event identifier [modifiers] declare_block {
    mixin="restart.language.mixin.MixinEvent"
}
kw_event           ::= "event" | "事件"
// ---------------------------------------------------------------------------------------------------------------------
hero_statement     ::= kw_hero identifier [modifiers] declare_block {
    mixin="restart.language.mixin.MixinHero"
};
kw_hero            ::= "character" | "hero" | "人物" | "英雄";
// ---------------------------------------------------------------------------------------------------------------------
talent_statement   ::= kw_talent identifier [modifiers] declare_block {
    mixin="restart.language.mixin.MixinTalent"
};
kw_talent          ::= "talent" | "skill" | "装备" | "物品" | "道具" | "天赋" | "技能" | "特质";
// ---------------------------------------------------------------------------------------------------------------------
archive_statement  ::= kw_archive identifier [modifiers] declare_block {
    mixin="restart.language.mixin.MixinAward"
}
kw_archive       ::= "award" | "成就";
// ---------------------------------------------------------------------------------------------------------------------
if_statement      ::= (KW_IF expression block) [ef_statement* [else_statement]]
ef_statement      ::= KW_ELSE_IF expression block;
else_statement    ::= KW_ELSE block;
block             ::= <<brace_free normal_statements SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
expression        ::= expr (op_binary expr)*;
private expr      ::= op_prefix* atoms (op_suffix|call_suffix|slice)*;
private op_binary ::=
      OP_SET | OP_EQ | OP_NE
    | OP_GT  | OP_LT | OP_GEQ | OP_LEQ
    | OP_ADD | OP_ADD_ASSIGN
    | OP_SUB | OP_SUB_ASSIGN
    | OP_MUL | OP_MUL_ASSIGN
    | OP_DIV | OP_DIV_ASSIGN
    | OP_MOD | OP_MOD_ASSIGN
    | OP_POW | OP_POW_ASSIGN
    | OP_AND | OP_OR
    // is | is not
    | OP_NOT_A | OP_IS_A OP_NOT | OP_IS_A | OP_NOT OP_IS_A
    | OP_AS
    // in | not in
    | OP_IN | OP_NOT_IN | OP_NOT OP_IN
private op_prefix ::= OP_ADD | OP_SUB | OP_NOT | BANG;
private op_suffix ::= BANG | QUESTION;
call_suffix       ::= <<parenthesis expression COMMA>>;
private delimiter ::= COMMA|SEMICOLON
// ---------------------------------------------------------------------------------------------------------------------
private atoms  ::= number | string | boolean | identifier;
boolean        ::= "true" | "false";
number         ::= (BYTE | INTEGER | DECIMAL) [NUMBER_SUFFIX] {
    mixin="restart.language.mixin.MixinNumber"
}
string         ::= [identifier] STRING_START STRING_TEXT STRING_END {
    mixin="restart.language.mixin.MixinString"
}
// ---------------------------------------------------------------------------------------------------------------------
identifier     ::= SYMBOL_XID | SYMBOL_RAW {
    mixin="restart.language.mixin.MixinIdentifier"
}
modifiers      ::= (identifier !end_m1)+ {
    mixin="restart.language.mixin.MixinModifier"
};
private end_m1 ::= (
    COLON|OP_PROPORTION|SEMICOLON|
    BRACKET_L|BRACKET_R|PARENTHESIS_L|PARENTHESIS_R|
    COMMA|OP_EQ|DOT
);
// ---------------------------------------------------------------------------------------------------------------------
private meta sequence      ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis   ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
private meta bracket_free  ::= BRACKET_L (<<item>>|<<sp>>)* BRACKET_R;
// brace { }
private meta brace_block   ::= BRACE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACE_R;
// brace { }
private meta brace_free    ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;