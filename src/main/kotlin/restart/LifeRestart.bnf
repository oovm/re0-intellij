{
    parserClass = "restart.language.parser.RestartParser"
    parserUtilClass = "restart.language.psi.RestartParserExtension"

    extends = "restart.language.ast.RestartASTBase"

    psiClassPrefix = "Restart"
    psiImplClassSuffix = "Node"
    psiPackage = "restart.language.psi"
    psiImplPackage = "restart.language.psi_node"

    elementTypeHolderClass = "restart.language.psi.RestartTypes"
    elementTypeClass = "restart.language.psi.RestartTokenType"
    tokenTypeClass = "restart.language.psi.RestartTokenType"

    psiImplUtilClass = "restart.language.ast.ASTMethods"
    generateTokenAccessors = false

    tokens = [
        COMMENT = "Comment"
        // literal
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        STRING_START = "StringStart"
        STRING_TEXT = "StringText"
        STRING_END = "StringEnd"
        BYTE = "Byte"

        DOT = '.'
        SEMICOLON = ';'
        COLON = ':'
        OP_PROPORTION = "::"

        OP_INC = "++"
        OP_ADD_ASSIGN = "+="
        OP_ADD = "+"
        OP_DEC = "--"
        OP_SUB_ASSIGN = "-="
        OP_SUB = "-"
        OP_MUL_ASSIGN = "*="
        OP_MUL = "*"
        OP_DIV_ASSIGN = "/="
        OP_DIV = "/"
        OP_MOD_ASSIGN = "%="
        OP_MOD = "%"

        OP_AND_ASSIGN = "&="
        OP_AND = "&"
        OP_AND2 = "&&"
        OP_OR_ASSIGN = "|="
        OP_OR = "|"
        OP_OR2 = "||"
        OP_POW = "^"
        // DOTS
        OP_ARROW = "->"
        OP_ARROW2 = "=>"
        //
        OP_EQ = "="
        OP_NE = "!="
        OP_BIND = ":="
        OP_NOT = "!"
        //
        OP_GT = ">"
        OP_GS = "/>"
        OP_GG = ">>"
        OP_GEQ = ">="
        OP_GGG = ">>>"
        //
        OP_LT = "<"
        OP_LS = "</"
        OP_LL = "<<"
        OP_LEQ = "<="
        OP_LLL = "<<<"
        OP_EMPTY = "(!)"

        OP_IS_A = "is"
        OP_NOT_A = "is not"

        OP_IN = "in"
        OP_NOT_IN = "not_in"
        OP_AND_THEN = "and_then"
        OP_OR_ELSE = "or_else"
        OP_FORALL = "forall"
        OP_EXISTS = "exists"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        SLICE_L = '[['
        SLICE_R = ']]'

        OP_NAMESAPCE = "namespace"

//        KW_NAMESPACE = "namespace"
//        KW_IMPORT = "using"
//        KW_EXTENSION = "extension"
//        KW_AS = "as"
//
//        KW_LET = "let"
//        KW_DEFINE = "def"
//        KW_NEW = 'new'
//
//        KW_IF = "if"
//        KW_ELSE = "else"
//        KW_FOR = "for"
//        KW_WHILE = "while"
//        KW_MATCH = 'match'
//        KW_CATCH = 'catch'
//
//        KW_CLASS = 'class'
//        KW_TRAIT = 'trait'
//        KW_TAGGED = 'tagged'
//        KW_BITFLAG = 'bitset'
//        KW_EXTENDS = 'extends'
    ]
}

re0 ::= ((top_statements|normal_statements) [SEMICOLON])*
private top_statements ::=
    variable_statement
  | event_statement
  | hero_statement
  | award_statement
  | declare_statement
  ;
private normal_statements ::=
    if_statement
  | for_statement
  | while_statement
  | expression
  ;
// ---------------------------------------------------------------------------------------------------------------------
declare_statement  ::= kw_declare identifier [modifiers] <<brace_block declare_item COMMA>> {
    mixin="restart.language.mixin.MixinDeclare"
}
kw_declare         ::= identifier
declare_item       ::=
    declare_key COLON normal_statements
  | declare_key COLON? <<bracket_free normal_statements delimiter>>
  | declare_key COLON? <<brace_block declare_item delimiter>>
  ;
declare_key       ::= identifier|number
pattern_item      ::= identifier* (DOT3|DOT2) identifier | identifier+;
// ---------------------------------------------------------------------------------------------------------------------
variable_statement ::= kw_variable identifier [modifiers] <<brace_block declare_item COMMA>> {
    mixin="restart.language.mixin.MixinProperty"
};
kw_variable        ::= "variable" | "property" | "属性"
// ---------------------------------------------------------------------------------------------------------------------
event_statement    ::= kw_event identifier [modifiers] <<brace_block declare_item COMMA>> {
    mixin="restart.language.mixin.MixinEvent"
}
kw_event           ::= "event" | "事件"
// ---------------------------------------------------------------------------------------------------------------------
hero_statement     ::= kw_hero identifier [modifiers] <<brace_block declare_item COMMA>> {
    mixin="restart.language.mixin.MixinHero"
};
kw_hero            ::= "character" | "hero" | "人物" | "英雄";
// ---------------------------------------------------------------------------------------------------------------------
award_statement    ::= kw_award identifier [modifiers] <<brace_block declare_item COMMA>> {
    mixin="restart.language.mixin.MixinAward"
}
kw_award           ::= "award" | "成就";
// ---------------------------------------------------------------------------------------------------------------------
if_statement      ::= (KW_IF condition block) [ef_statement* [else_statement]]
ef_statement      ::= kw_else_if condition block;
kw_else_if        ::= "else" KW_IF | "ef"
else_statement    ::= "else" block;
condition         ::= case_pattern OP_SET expression | expression;
case_pattern      ::= CASE [identifier* [namepath]] declare_item;
private block     ::= <<brace_block expression SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
for_statement     ::= KW_FOR (case_pattern|normal_pattern) KW_IF expression [if_guard] block [else_statement];
if_guard          ::= KW_IF condition;
normal_pattern    ::= identifier* declare_item | <<sequence pattern_item COMMA>> {
    mixin="restart.language.mixin.MixinNormalPattern"
};
// ---------------------------------------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------------------------------------
while_statement   ::= WHILE condition block;
// ---------------------------------------------------------------------------------------------------------------------
expression        ::= expr (op_binary expr)*;
private expr      ::= op_prefix* term (op_suffix|call_suffix|slice)*;
private op_binary ::=
      OP_SET | OP_EQ | OP_NE
    | OP_ADD | OP_ADD_ASSIGN
    | OP_SUB | OP_SUB_ASSIGN
    | OP_MUL | OP_MUL_ASSIGN
    | OP_DIV | OP_DIV_ASSIGN | OP_MOD | OP_MOD_ASSIGN
    | OP_POW | OP_POW_ASSIGN
    | OP_GT | OP_LT | DOT_LESS | DOT_EQ | DOT2 | DOT
    | OP_TO
    | OP_AND_THEN | OP_OR_ELSE
    // is | is not
    | OP_NOT_A | OP_IS_A OP_NOT | OP_IS_A | OP_NOT OP_IS_A
    | OP_AS
    // in | not in
    | OP_IN | OP_NOT_IN | OP_NOT OP_IN
private op_prefix ::= OP_ADD | OP_SUB | OP_NOT | BANG | AMP | DOT3 | DOT2;
private op_suffix ::= BANG | QUESTION;
call_suffix       ::= <<parenthesis expression COMMA>>;
private delimiter ::= COMMA|SEMICOLON
// ---------------------------------------------------------------------------------------------------------------------
private term   ::= range | list | tuple | atoms;
tuple          ::= <<parenthesis expression COMMA>>
list           ::= <<bracket_free expression COMMA>>
range          ::= <<slice_block slice_item COMMA>>;
slice          ::= <<slice_block slice_item COMMA>>;
slice_item     ::=
    [expression] COLON [expression] COLON [expression]
  | [expression] COLON [expression]
  | [expression] OP_PROPORTION [expression]
  | expression;
// ---------------------------------------------------------------------------------------------------------------------
private atoms  ::= number | string | boolean | namepath;
boolean        ::= "true" | "false";
number         ::= (BYTE | INTEGER | DECIMAL) [identifier] {
    mixin="restart.language.mixin.MixinNumber"
}
string         ::= [identifier] STRING_START STRING_TEXT STRING_END {
    mixin="restart.language.mixin.MixinString"
}
// ---------------------------------------------------------------------------------------------------------------------
namepath       ::= identifier (OP_PROPORTION identifier)* {
    mixin="restart.language.mixin.MixinNamepath"
}
identifier     ::= SYMBOL_XID | SYMBOL_RAW {
    mixin="restart.language.mixin.MixinIdentifier"
}
modifiers      ::= (identifier !end_m1)+ {
    mixin="restart.language.mixin.MixinModifier"
};
private end_m1 ::= (
    COLON|OP_PROPORTION|SEMICOLON|
    BRACKET_L|BRACKET_R|PARENTHESIS_L|PARENTHESIS_R|
    COMMA|OP_EQ|DOT
);
// ---------------------------------------------------------------------------------------------------------------------
private meta sequence      ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis   ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
meta bracket_free          ::= BRACKET_L (<<item>>|<<sp>>)* BRACKET_R;
// brace { }
meta brace_block   ::= BRACE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACE_R;
// brace { }
private meta brace_free    ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;
// angle ::< >::
private meta angle_block   ::= OP_LT [<<item>> (<<sp>> <<item>>)* [<<sp>>]] OP_GT;
// angle ⟦ ⟧
private meta slice_block   ::= SLICE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] SLICE_R;